####################################################################
# $Id$
# by Andrew C. Uselton <uselton2@llnl.gov> 
# Copyright (C) 2000 Regents of the University of California
# See ../DISCLAIMER
# v. 0-0-1:  2001-07-11
# v. 0-0-2:  2001-07-31
####################################################################
			PowerMan
		     Andrew Uselton
		      June 27, 2001
		    update: 2001-07-11

"PowerMan" is a project to incorporate power management and monitoring
functionality for various node types in a cluster into a single
application and library.  We currently support these node types: CS20,
DS20, ES40, and UP2000 (DS10 would be similar).  "Powerman" is the
name of the project and also the name of an application exercising the
library, which is called "powerlib.tcl".  The application is written
in "tcl", as are all of the libraries.  The application is evaluated by
"#!/usr/bin/expect --", since the "conman.exp" functionality (for
communicating with RMC) expects "expect."  We also plan an snmp agent
extension calling into the same library.

Powerman is written in tcl and has the following calling convention:   
powerman [-c configfile] [-l libdir] [-defhqrv] [-on | -off] nodes ...

Powerman with no command line parameters or with -h (and anything)
prints a usage summary.
1) -c configfile will read in configfile instead of the default 
2) -d means print debugging information
3) -e makes node list items be iterpreted as regular expressions
4) -f forces the specified action without confirmation
5) -l libdir will read the tcl libraries from libdir
6) -q make the command a query, i.e. power status is returned and no
     other actin is taken
7) -r reset the nodes, -r is mutually exclusive with both -q and +/-
8) -on turns on the specified nodes
9) -off turns off the specified nodes
10) -v means be verbose about what you're doing
11) "nodes" is a comma separated list of nodes, where each element in
      the list is interpreted via standard globbing (unless -e is
      present) 

There may be several "nodes" entries on the command line as long as
they are separated by a space, as in:
# powerman -q -on slc1,slc2 slc1*
Note that this command will include slc1 twice.  All of the actions
taken by "powerman" are idempotent, so this is allowed and has no
harmfull effect.  

Powerman will look for the config file "/etc/powerman.conf" by
default, and the environment variable POWERMANCONF will override that
choice, while the -c option takes precedence.  Similarly, powerman
will look for its libraries in "/usr/lib/powerman" by default, and the
environment variable POWERMANLIBDIR will override that choice, while
the -l option takes precedence.

Powerman processes its command line parameters, reads in the cluster
configuration file and the powerlib.tcl library, and assembles the
requested nodes into a list. It calls init, and passes that list to
the appropriate libarary routine in powerlib.tcl.  Upon return it
prints a meaningfull message.  Other printing takes place according to
-v and -d switches.

Powerlib.tcl has theseroutines: 

1.  init -  Read the configuration file for the cluster and call init
            routines for the included types 
2.  do_on - (try to) turn on a set of nodes
3.  do_off - (try to) turn off a set of nodes
4.  do_reset - (try to) reset a set of nodes
5.  check_on - return the set of nodes that are on from among a given
               set of nodes
6.  check_off - return the set of nodes that are off from among a
                given set of nodes
7.  fini - perform any needed finalizations

Each type of node accomplishes these activities differetly, so there
is a low level library for each one.  The currently availablelibraries
are: 
cs20_powerlib.tcl 
ds20_powerlib.tcl 
es40_powerlib.tcl
up2000_powerlib.tcl 
Each library implements the above seven functions as applied to the
corresponding hardware type.  For instance "cs20_powerlib.tcl"
implements "cs20_do_on" by accepting a list of cs20 nodes, determining
the subset that are off, and sending that subset "ether-wake" toggle
packets.  NB sending an "ether-wake" toggle packet to a node that is
already on would turn it off - probably not what was intended and
violating indepotency.  NB2 "cs20_do_on" sequences through its list in
order - an attempt to do this in parallel could end up with a race
condition and fail to be idempotent.  

In powerlib.tcl init reads in the configuration file, powerman.conf,
which tells the library the names of all the nodes and their types,
along with other usefull information.  It assembles a list of all the
node types included, for each node type it includes the
<type>_powerlib.tcl library and calls the init function for that
<type>_powerlib.tcl.

Each of do_on, do_off, and do_reset in powerlib.tcl acts as follows:
It presumes that init has been called.  It partitions the list of
nodes into a list for each type and calls the corresponding function
in <type>_powerlib.tcl with that list.  

Each of check_on and check_off in powerlib.tcl acts as follows:
It presumes that init has been called.  It partitions the list of
nodes into a list for each type and calls the corresponding function
in <type>_powerlib.tcl with that list.  It returns the concatenation
of the lists returned to it from the <type>_powerlib.tcl calls.  

In powerlib.tcl fini calls the corresponding function in each
<type>_powerlib.tcl.  

The configuration file "powerman.conf" is just a tcl script to set the
global variables "type" and "cluster" to values reflecting the
structure of the cluster in question.  The variable "configed" just
assists in suppressing the evaluation of the config file a second
time. 
# powerman.conf for the slc cluster
set configed 1
set types {up2000 cs20 es40}
set cluster {
	{slc0  {type "up2000"} {<attribute> <value> ...} ... } 
	...
} 
"Cluster" is a list of "node records" and each node record begins with
a name for the node and an attribute/value pair giving the type of the
node.  The node record may contain any number of additional
attribute/value entries and each atribute may be associated with any
number or structer of values.  All of the information in these
additional attribute/value entries is interpreted by the
<type>_powerlib.tcl library, and it is up to the administrator setting
up the cluster to be sure and provide the correct data.  

On the UP2000 the on, off, and reset functions are commands sent to
the /dev/ttyD23 port controlling the external power controllers.  On
the ES40s these functions are implemented via expect scripts through
"conman" communicating with the RMC>> facility.  On the CS20s they are
implemented via the "ether-wake" program, which is compiled from
Scyld's ether-wake.c with the included Makefile.  "Ether-wake" also
needs the nodes hardware MAC address, and this is provided by the
"show_dev.exp" expect script in the "conman" suite - an early version
of that command is in this distribution, though it will be supplanted
by "conman" eventually.

As of June 27th the ES40's expect scripts are still under development,
the CS20's ether-wake program is awaiting a working Wake-On-LAN BIOS
on the one node we have (slc6), and the power monitoring functionality
only works completely on nodes slc[6,14,15] (the cs20 and two ES40s)
where special connector "dongles" merge the pin-1 output of the
parallel port into the pin-4 DSR line of the DB9 serial port 1 output.
Additionaly, slc[0-5] (the UP2000s) will reflect correct power status
except just after power-on, and just after boot.  slc[8-13] (the
remaining ES40s) will always show "power off" status until we provide
dongles.

For each library there are four perl scripts, one for each function,
for testing the corresponding functions.  
UP2000_powerlib.pl  ES40_powerlib.pl  CS20_powerlib.pl
------------------  ----------------  ----------------
up2000_check        es40_check        cs20_check
up2000_on           es40_on           cs20_on
up2000_off          es40_off          cs20_off
up2000_reset        es40_reset        cs20_reset
Each takes a (space separated) list of nodes from the command line and
calls the library for the approriate command.  The script calls the
"init" and "fin" functions and refuses to turn off an already off node,
etc.  Note that the "up2000_check" script returns shell script style
return values, i.e. 0 means "is on" and 1 means "is off".  Each test
function also prints out a short message stating what it is doing.
The libraries, in general, are silent.  

The scripts "monitor" and "altmon" are low level calls to the "ditty"
command or "the up2000_check" command that repeat at one second
intervals.  You may want to have a similar script giving you continual
staus while you experiment with the various commands.  

The library "powerlib.pl" gathers the other three libraries and
implements the (check, on, off, reset) suite at the level of the whole
cluster.  Thus each call is dispatched to the appropriate node
specific implementation based on knowing the composisiton of the
cluster.  "Powerlib.pl" also implements some new functions.
"Power_cluster" returns a list of the nodes in the cluster.
"Power_stat" returns a hash of the power status of all nodes in the
cluster, though it only actually sets the power status of those nodes
in the called command line - the others are set to a neutral
($UNASKED) value.  The new function "nodes_on" returns "ON" only if
all the nodes in the command line are on.  Similarly, "nodes_off"
returns "OFF" only if all the nodes are off.  

Finally, there is a commandline script for each of the four functions
att the "powerlib.pl" level, i.e. irrespective of the node type.  All
of these scripts are still specific just to the slc cluster, so the
four functions are:
slc_check
slc_on
slc_off
slc_reset
There is one more script, "slc_stat", that prints a vector of power
indicators the length of the cluster.  Each indicator has a 1 for "ON",
a 0 for "OFF", a "-" if the corresponding node was not on the command
line, and a "?" if the node was queried but a status could not be
determined (this last shouldn't happen except as a bug).  

Work that remains to be done includes the following:
1.  Incorporate the expect scripts that will turn on, turn off, and
      reset the ES40 nodes (and DS10s and DS20s)
2.  Fix the Wake-On-LAN facility in the CS20 and test it
3.  Incorporate globbing and regexp expansion for node lists
4.  Abstract the node details into a configuration file
5.  Standardize the calling conventions so that a script knows where
      to find all the libraries, maybe combine all the libraries into
      a single file
6.  Clean up the interfaces, document, and regularize the code
7.  Determine if the Perl implementation is adequate or if it needs to
    be reimplemented in C
8.  Write the necessary scripts to extract cluster configuration
      information from Genders and put it in the configuration file
9.  Integrate with "conman", esp the showdev.exp and other expect 
      scripts