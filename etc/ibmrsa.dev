#
# $Id$
# $Source$
#
# IBM Remote Supervisor Adapter (RSA) with system management connector
# disconnected.
#
# The RSA is an externally powered PCI adapter with its own ethernet connection
# and an RS485 interface.  The RS485 interface daisy chains serveral IBM
# xSeries nodes, including the node hosting the RSA adapter.  The xSeries 
# nodes have a service processor, based on the H8 microprocessor (the "hawk")
# integrated into the mainboard.  The RSA adapter can forward power 
# on/off/status commands to the hawks via RS485.
# 
# Normally the RSA's provide a web front end.  PowerMan uses an undocumented
# debug interface available by telnetting into the RSA and typing ctrl-D.
# The 'power' command in debug mode was first added in April 2003 in f/w 
# versions: GEET117A (x345) and T2ET116A (x335).
#
# The 'power' command takes dynamically assigned RS485 ID's.  The login script
# uses the 'remotesp' command to map hostnames to RS485 ID's, which PowerMan
# uses as plug names.  
#
# Note: This script assumes the "system management connector" between the
# motherboard and the RSA is disconnected.  With this cable disconnected, the
# RSA does not take over service processor functionality of the on-board hawk.
# This allows the node hosting the RSA adapter to be controlled in the same
# manner as "remote" nodes.  See ibmrsa-smc.dev for a device script that works
# with the cable connected.
# 
# Caveat: powerman is sensitive to the number of lines returned by the various 
# RSA commands.  If one of the nodes in a chain is externally powered off or 
# removed from the RS485 chain, powerman will time out commands targetted at 
# that chain.  If a node is out long term, it should be commented out in the 
# powerman.conf file.
#
specification "ibmrsa" {
	timeout  	20

	script login {
		expect "Login ID:"
		send "USERID\r\n"
		send "PASSW0RD\r\n"
		expect "Select" 
		delay 1
		send "\004"  			# ^D to enter "debug mode"
		expect "==> "

		send "remotesp\r\n"
		foreachnode {
			expect "[^ ]+[ ]+([^ ]+)[ ]+Hawk[ ]+([0-9A-F]{2})"
			setplugname $2 $1	# <plug> <node>
		}
	}
	script logout {
		send "\004"  			# ^D to log completely off
	}
	script status_all {
		send "power 2 0\r\n"
		foreachnode {
			expect "Server 0x([0-9A-F]{2}) Status = (on|off)\r\n"
			setplugstate $1 $2 on="on" off="off"
		}
	}
	script on {
		send "power 1 %s\r\n"
		expect "Status = on\r\n"
	}
	script on_all {
		send "power 1 0\r\n"
		foreachnode {
			expect "Server 0x([0-9A-F]{2}) Status = (on|off)\r\n"
		}
	}
	script off {
		send "power 0 %s\r\n"
		expect "Status = off\r\n"
	}
	script off_all {
		send "power 0 0\r\n"
		foreachnode {
			expect "Server 0x([0-9A-F]{2}) Status = (on|off)\r\n"
		}
	}
	script cycle {
		send "power 0 %s\r\n"
		expect "Status = off\r\n"
		delay 2
		send "power 1 %s\r\n"
		expect "Status = on\r\n"
	}
	script cycle_all {
		send "power 0 0\r\n"
		foreachnode {
			expect "Server 0x([0-9A-F]{2}) Status = (on|off)\r\n"
		}
		delay 2
		send "power 1 0\r\n"
		foreachnode {
			expect "Server 0x([0-9A-F]{2}) Status = (on|off)\r\n"
		}
	}
}
