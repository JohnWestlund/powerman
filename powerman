#!/usr/bin/expect --
####################################################################
# $Id$
# by Andrew C. Uselton <uselton2@llnl.gov> 
# Copyright (C) 2000 Regents of the University of California
# See ../DISCLAIMER
# v. 0-0-1:  2001-07-11
# v. 0-0-2:  2001-07-31
####################################################################
# powerman [-c file] [-l libdir] [-defhqrv] [-on | -off] {nodes ...}

proc usage msg {
  global argv0
  puts "usage: $argv0 \[-c file\] \[-l libdir\] \[-defhqrv\] \[-on | -off\] {nodes ...}"
  puts "-c file   = load file as config file"
  puts "-d        = debugging output"
  puts "-e        = use regular expressions instead of globbing"
  puts "-f        = force the action without confirmation"
  puts "-l libdir = look for tcl libs in libdir"
  puts "-q        = query the state instead of setting it"
  puts "-r        = reset the nodes, mutually exclusive with -q, -on, and -off"
  puts "-v        = be verbose"
  puts "-on       = turn on nodes (the default)"
  puts "-off      = turn off nodes"
  puts "nodes     = comma separated list (no spaces), each item is globbed,"
  puts "              (list of) nodes may be repeated separated by spaces"
  puts $msg
  exit
}

proc read_nodes node_list {
    global regex
    global cluster
    set return_nodes {}
    set j 0
    set k [string length $node_list]
    for {set i 0} {$i < $k} {set i [expr $j+2]} {
	set j [string first "," [string range $node_list $i $k]]
	if {$j < 0} {set j $k} else {incr j [expr $i-1]}
	set node_expr [string range $node_list $i $j]
	set nlist $powerlib::nodes
	if {$regex} {
	    set index [lsearch -regexp $nlist $node_expr]
	} else {
	    set index [lsearch $nlist $node_expr]
	}
	while { $index >= 0 } {
	    set node [lindex $nlist $index]
	    lappend return_nodes $node
	    set nlist [lrange $nlist [incr index] end]
	    if {$regex} {
		set index [lsearch -regexp $nlist $node_expr]
	    } else {
		set index [lsearch $nlist $node_expr]
	    }
	}
    }
  return $return_nodes
}


if { [exec id -u] } {
	set unlockable 0
} else {
 	set unlockable 1
}

namespace eval app {}

if {$argc < 1} { usage "need arguments" }

set app::config_file "/etc/powerman.conf"
if {[info exists env(POWERMANCONF)]} {
    set app::config_file $env(POWERMANCONF)
}
set app::lib_dir "/usr/lib/powerman"
if {[info exists env(POWERMANLIBDIR)]} {
    set app::lib_dir $env(POWERMANLIBDIR)
}
set configed 0
set debug 0
set regex 0
set force 0
set reset 0
set app::verbose 0
set node_list   {}
set on      0
set off     0
set app::tkdanger 0
for {set i 0} {$i < $argc} {incr i} {
  switch -- [lindex $argv $i] {
      "-c" { 
	  incr i
	  set app::config_file [lindex $argv $i]
      }
      "-d" {set debug 1}
      "-e" {set regex 1}
      "-f" {set force 1}
      "-l" { 
	  incr i
	  set app::lib_dir [lindex $argv $i]
      }
      "-q" {set query 1}
      "-r" {set reset 1}
      "-v" {set app::verbose 1}
      "-on"  {if { $unlockable } {set on  1} else {puts "Root Only"}}
      "-off" {if { $unlockable } {set off 1} else {puts "Root Only"}}
      default {
	  if {!$configed} {
	      if {![file exists $app::config_file]} {
		  usage "Can't find config file"
	      }
              set powerlib [format "%s/powerlib.tcl" $app::lib_dir]
              if {[file exists $powerlib]} {
                  source $powerlib
              } else {
                  usage "Can't find $powerlib library"
              }
              set configed 1
	  }
          set node_list [ concat $node_list [read_nodes [lindex $argv $i]]]
      }
  } 
}


if {$reset && $query}         {usage "Can't have both reset and query"} 
if {$on + $off + $reset != 1} {usage "Need exactly one of on, off, or reset" }

	
if {$app::verbose} {
    if {$on} {
	if {$query} {puts "Here's who were're checking who's on"} else {
	    puts "Turning on these guys"
	}
    }
    if {$off} {
	if {$query} {puts "Here's who were're checking for who's off"} else {
	    puts "Turning off these guys"
	}
    }
    if {$reset} {
	puts "Resetting these guys"
    }
    puts $node_list
}

# At this point all the globals should be in place.  Next the command 
# is dispatched to its handler. 

if {$on} {
    if {$query} {
	set response [powerlib::check $node_list on]
	set num_resp [llength $response]
	if {$num_resp == 0} {puts "None are on"} else {
	    if {$num_resp == 1} {puts "$response is on"} else {
		puts "$response are on"
	    }
	}
    } else {
	powerlib::power $node_list on
    }
}
if {$off} {
    if {$query} {
	set response [powerlib::check $node_list off]
	set num_resp [llength $response]
	if {$num_resp == 0} {puts "None are off"} else {
	    if {$num_resp == 1} {puts "$response is off"} else {
		puts "$response are off"
	    }
	}
    } else {
	powerlib::power $node_list off
    }
}
if {$reset} {
    powerlib::power $node_list reset
}




