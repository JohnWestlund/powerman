#!/usr/bin/expect --
####################################################################
# $Id$
# by Andrew C. Uselton <uselton2@llnl.gov> 
# Copyright (C) 2000 Regents of the University of California
# See ../DISCLAIMER
# v. 0-0-1:  2001-07-11
# v. 0-0-2:  2001-07-31
# v. 0-0-3:  2001-08-08
#            Allows for non-root access to query mode.
#            Checks for empty node list.
#            New -V option for version string.
#            Minor rearrangement of powerlib namespace to allow for
#               (other apps) dynamically loading and unloading 
#               cluster descriptions
####################################################################
# powerman [-c file] [-l libdir] [-defhqv] [-on | -off | -r] {nodes ...}

proc usage msg {
  global argv0
  puts "usage: $argv0 \[-c file\] \[-l libdir\] \[-dehqrv\] \[-on | -off\] {nodes ...}"
  puts "-c file   = load file as config file"
  puts "-d        = debugging output"
  puts "-e        = use regular expressions instead of globbing"
  puts "-l libdir = look for tcl libs in libdir"
  puts "-q        = query the state instead of setting it"
  puts "-r        = reset the nodes, mutually exclusive with -q, -on, and -off"
  puts "-v        = be verbose"
  puts "-V        = print version and exit"
  puts "-on       = turn on nodes (the default)"
  puts "-off      = turn off nodes"
  puts "nodes     = comma separated list (no spaces), each item is globbed,"
  puts "              (list of) nodes may be repeated separated by spaces."
  puts "              You may want to put it in quotes to prevent shell expansion."
  puts $msg
  exit
}

proc read_nodes {node_list} {
    set return_nodes {}
    set j 0
    set k [string length $node_list]
    for {set i 0} {$i < $k} {set i [expr $j+2]} {
	set j [string first "," [string range $node_list $i $k]]
	if {$j < 0} {set j $k} else {incr j [expr $i-1]}
	set node_expr [string range $node_list $i $j]
	set nlist $powerlib::nodes
	if {$::app::regex} {
	    set index [lsearch -regexp $nlist $node_expr]
	} else {
	    set index [lsearch $nlist $node_expr]
	}
  	while { $index >= 0 } {
	    set node [lindex $nlist $index]
	    lappend return_nodes $node
	    set nlist [lrange $nlist [incr index] end]
	    if {$::app::regex} {
		set index [lsearch -regexp $nlist $node_expr]
	    } else {
		set index [lsearch $nlist $node_expr]
	    }
	}
    }
  return $return_nodes
}

set Version "PowerMan 0.0.3"

if { [exec id -u] } {
	set unlockable 0
} else {
 	set unlockable 1
}

namespace eval app {}

if {$argc < 1} { usage "need arguments" }

set app::config_file "/etc/powerman.conf"
if {[info exists env(POWERMANCONF)]} {
    set app::config_file $env(POWERMANCONF)
}
set app::lib_dir "/usr/lib/powerman"
if {[info exists env(POWERMANLIBDIR)]} {
    set app::lib_dir $env(POWERMANLIBDIR)
}
set ::app::configed      0
set ::app::debug         0
set ::app::regex         0
set ::app::verbose  0
set ::app::node_list     {}
set ::app::query         0 
set ::app::on            0
set ::app::off           0
set ::app::reset         0
set ::app::tkdanger      0

for {set i 0} {$i < $argc} {incr i} {
  switch -- [lindex $argv $i] {
      "-c"    { 
	  incr i
	  set app::config_file [lindex $argv $i]
      }
      "-d"    {set ::app::debug 1}
      "-e"    {set ::app::regex 1}
      "-l"    { 
	  incr i
	  set app::lib_dir [lindex $argv $i]
      }
      "-q"    {set ::app::query 1}
      "-r"    {set ::app::reset 1}
      "-v"    {set ::app::verbose 1}
      "-V"    {
	  puts "$Version"
	  exit
      }
      "-on"   {set ::app::on  1}
      "-off"  {set ::app::off 1}
      default {
	  if {!$::app::configed} {
	      if {![file exists $app::config_file]} {
		  usage "Can't find config file"
	      }
              set powerlib [format "%s/powerlib.tcl" $app::lib_dir]
              if {[file exists $powerlib]} {
                  source $powerlib
# The argument for not sourcing the subsidiary powermanagement scripts
# here is that I'll want to be able to load and unload configurations
# in other apps, and that is probably better done subsidiary to the
# powerlib namespace
		  ::powerlib::init $app::config_file
              } else {
                  usage "Can't find $powerlib library"
              }
              set ::app::configed 1
	  }
          set ::app::node_list [ concat $::app::node_list [read_nodes [lindex $argv $i]]]
      }
  } 
}

if {[llength $::app::node_list] == 0} {usage "No nodes specified (use \"\*\" for all)"}

if {$::app::reset && $::app::query}         {usage "Can't have both reset and query"} 
if {$::app::on + $::app::off + $::app::reset != 1} {usage "Need exactly one of on, off, or reset" }
if {!$::app::query && !$unlockable}  {
	puts "You must be root to do this"
	exit
} 
	
if {$::app::verbose} {
    if {$::app::on} {
	if {$::app::query} {puts "Here's who were're checking who's on"} else {
	    puts "Turning on these guys"
	}
    }
    if {$::app::off} {
	if {$::app::query} {puts "Here's who were're checking for who's off"} else {
	    puts "Turning off these guys"
	}
    }
    if {$::app::reset} {
	puts "Resetting these guys"
    }
    puts $::app::node_list
}

# At this point all the globals should be in place.  Next the command 
# is dispatched to its handler. 

if {$::app::on} {
    if {$::app::query} {
	foreach resp [powerlib::check $::app::node_list on] {
	    puts "$resp"
	}
    } else {
	powerlib::power $::app::node_list on
    }
}
if {$::app::off} {
    if {$::app::query} {
	foreach resp [powerlib::check $::app::node_list off] {
	    puts "$resp"
	}
    } else {
	powerlib::power $::app::node_list off
    }
}
if {$::app::reset} {
    powerlib::power $::app::node_list reset
}




