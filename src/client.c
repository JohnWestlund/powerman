/*****************************************************************************\
 *  $Id$
 *****************************************************************************
 *  Copyright (C) 2001-2002 The Regents of the University of California.
 *  Produced at Lawrence Livermore National Laboratory (cf, DISCLAIMER).
 *  Written by Andrew Uselton (uselton2@llnl.gov>
 *  UCRL-CODE-2002-008.
 *  
 *  This file is part of PowerMan, a remote power management program.
 *  For details, see <http://www.llnl.gov/linux/powerman/>.
 *  
 *  PowerMan is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU General Public License as published by the Free
 *  Software Foundation; either version 2 of the License, or (at your option)
 *  any later version.
 *  
 *  PowerMan is distributed in the hope that it will be useful, but WITHOUT 
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 *  for more details.
 *  
 *  You should have received a copy of the GNU General Public License along
 *  with PowerMan; if not, write to the Free Software Foundation, Inc.,
 *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.
\*****************************************************************************/

#include <string.h>
#include <errno.h>
#include <assert.h>
#include <syslog.h>

#include <arpa/inet.h>
#include <tcpd.h>
#include <fcntl.h>

#include "powerman.h"
#include "wrappers.h"
#include "list.h"
#include "config.h"
#include "powermand.h"
#include "client.h"
#include "buffer.h"
#include "error.h"
#include "string.h"
#include "util.h"
#include "action.h"

#define LISTEN_BACKLOG    5

/* prototypes */
static Action *_process_input(Client *c);
static Action *_find_cli_script(String expect);
static bool _match_cli_template(Action *act, regex_t *re,String expect);
static void _destroy_client(Client * client);

/* tcp wrappers support */
extern int hosts_ctl(char *daemon, char *client_name, char *client_addr, 
		char *client_user);
int allow_severity = LOG_INFO;		/* logging level for accepted reqs */
int deny_severity = LOG_WARNING;	/* logging level for rejected reqs */

/* module data */
static int listen_fd = NO_FD;
static List powerman_clients = NULL;
static Protocol *client_prot = NULL;


/* helper for cli_init */
static void
_mkexpect(List *script, char *str)
{
    Script_El *script_el;
    struct timeval tv;

    tv.tv_sec = tv.tv_usec = 0;
    tv.tv_usec = 0;
    *script = list_create((ListDelF) conf_script_el_destroy);
    script_el = conf_script_el_create(EXPECT, str, NULL, tv);
    list_append(*script, script_el);
}

/*
 * Initialize module
 */
void cli_init(void)
{
    List *scripts;

    assert(client_prot == NULL);

    /* create powerman_clients list */
    powerman_clients = list_create((ListDelF) _destroy_client);

    /* 
     * Initialize the expect/send pairs for the client protocol. 
     * Each one has exactly one EXPECT.  
     */
    client_prot = (Protocol *) Malloc(sizeof(Protocol));

    scripts = (List *) Malloc(NUM_SCRIPTS * sizeof(List));
    client_prot->scripts = scripts;
    client_prot->num_scripts = NUM_SCRIPTS;
    client_prot->mode = REGEX;

    /*
     *  N.B. The server.c:client_reply() function hard codes the actual
     * replies generated by each command.  The following are just the 
     * means for detecting which function the client in instigating.  
     */
    scripts[PM_ERROR] = NULL;
    _mkexpect(&scripts[PM_LOG_IN],	    "powerman");
    _mkexpect(&scripts[PM_CHECK_LOGIN],	    "check login");
    _mkexpect(&scripts[PM_LOG_OUT],	    "quit");
    _mkexpect(&scripts[PM_UPDATE_PLUGS],    "update plugs");
    _mkexpect(&scripts[PM_UPDATE_NODES],    "update nodes");
    _mkexpect(&scripts[PM_POWER_ON],	    "on ([^[:space:]]+)");
    _mkexpect(&scripts[PM_POWER_OFF],	    "off ([^[:space:]]+)");
    _mkexpect(&scripts[PM_POWER_CYCLE],	    "cycle ([^[:space:]]+)");
    _mkexpect(&scripts[PM_RESET],	    "reset ([^[:space:]]+)");
    _mkexpect(&scripts[PM_NAMES],	    "names ([^[:space:]]+)");
}

/*
 * Finalize module.
 */
void
cli_fini(void)
{
    int i;

    assert(client_prot != NULL);

    /* destroy clients */
    list_destroy(powerman_clients);

    /* destroy client protocol */
    for (i = 0; i < client_prot->num_scripts; i++)
	list_destroy(client_prot->scripts[i]);
    Free(client_prot);
    client_prot = NULL;
}


/*
 *   Select has indicated that there is material read to
 * be read on the fd associated with the Client c. 
 *   If there was in fact stuff to read then that stuff is put
 * in the "from" buffer for the client.  If a (or several) 
 * recognizable command(s) is (are) present then it is interpreted 
 * and put in a Server Action struct which is queued to
 * be processed when the server is Quiescent.  If the 
 * material is recognizably wrong then an error is returned 
 * to the client.  If there isn't a complete command (no '\n')
 * then the "from" buf keeps the data for later completion.
 * If there was nothing to read then it may be time to 
 * close the connection to the client.   
 */
static void _handle_client_read(Client * c)
{
    int n;
    Action *act = NULL;

    CHECK_MAGIC(c);

    n = buf_read(c->from);
    if ((n < 0) && (errno == EWOULDBLOCK))
	return;
    if (n <= 0) {
	/* EOF close or wait for writes to finish */
	c->read_status = CLI_DONE;
	return;
    }

    do {
	/* 
         *   If there isn't a full command left in the from buffer then this 
         * returns NULL. Otherwise it will return a newly created Action
         * act, extract the next command from the buffer, set the
         * Action fields client, seq, com, num and target for later
         * processing, and enqueue the Action.  
         */
	act = _process_input(c);
	if (act != NULL)
	act_add(act);
    }
    while (act != NULL);

}


/*
 *   Some new stuff is in the "from" buf.  
 *   Look the suff over and try to build a Server Action.  
 * Returning a NULL means something is there but not enough 
 * to interpret.  If it's recognizably a bad command then
 * return a Server Action with com = PM_ERROR.  That and the
 * "PM_CHECK_LOGIN" command is responded to immediately.  The
 * others require sending the Server Action to the devices 
 * first.
 */
static Action *_process_input(Client * c)
{
    Action *act;
    String expect;

    /* Using NULL means I'll just get the next '\n' terminated string */
    /* but with any '\r' or '\n' stripped off */
    expect = util_bufgetline(c->from);
    if (expect == NULL)
	return NULL;

    act = _find_cli_script(expect);
    str_destroy(expect);
    if (act != NULL) {
	act->client = c;
	act->seq = c->seq++;
    }
    return act;
}

/*
 *   Select has notified that it is willing to accept some 
 * write data.
 *   If the client is wanting to close the connection 
 * and the write buffer is clear then close the 
 * connection.
 */
static void _handle_client_write(Client * c)
{
    int n;

    CHECK_MAGIC(c);

    n = buf_write(c->to);
    if (n < 0)
	return;			/* EWOULDBLOCK */

    if (buf_isempty(c->to))
	c->write_status = CLI_IDLE;
}

/*
 *   Returning a NULL means there is not a complete unprocessed
 * command in the "from" buffer.  I.e. nothing to be done.
 * A complete command would be indicated by a '\n'.  There
 * could be more than one.
 */
static Action *_find_cli_script(String expect)
{
    Action *act;
    bool found_it = FALSE;
    regex_t *re;

    assert(client_prot != NULL);

    act = act_create(PM_ERROR);
    /* look through the array for a match */
    while ((!found_it) && (act->com < (NUM_SCRIPTS - 1))) {
	act->com++;
	assert(client_prot->scripts[act->com] != NULL);
	act->itr = list_iterator_create(client_prot->scripts[act->com]);
	act->cur = list_next(act->itr);
	assert(act->cur->type == EXPECT);
	re = &(act->cur->s_or_e.expect.exp);
	found_it = _match_cli_template(act, re, expect);
	list_iterator_destroy(act->itr);
	act->itr = NULL;
    }
    if (!found_it)
	act->com = PM_ERROR;
    return act;
}

/*
 *   This function tries to match the given RegEx if it does then
 * depending on which command we're talking about it either returns
 * TRUE and is doen, or it goes on to scan for an RegEx that the
 * Client sent in.  Finding one, it puts it in tthe Action's "target"
 * field.
 */
static bool _match_cli_template(Action * act, regex_t * re, String expect)
{
    int n;
    int l;
    size_t nmatch = MAX_MATCH;
    regmatch_t pmatch[MAX_MATCH];
    int eflags = 0;
    char buf[MAX_BUF];
    char *str = str_get(expect);

    CHECK_MAGIC(act);

    re_syntax_options = RE_SYNTAX_POSIX_EXTENDED;
    n = Regexec(re, str, nmatch, pmatch, eflags);
    if (n != REG_NOERROR)
	return FALSE;
    if (pmatch[0].rm_so < 0)
	return FALSE;

    switch (act->com) {
    case PM_ERROR:
	assert(FALSE);
    case PM_LOG_IN:
    case PM_CHECK_LOGIN:
    case PM_LOG_OUT:
    case PM_UPDATE_PLUGS:
    case PM_UPDATE_NODES:
	return TRUE; /* don't need target data */
    case PM_POWER_ON:
    case PM_POWER_OFF:
    case PM_POWER_CYCLE:
    case PM_RESET:
    case PM_NAMES:
	assert((pmatch[1].rm_so >= 0) && (pmatch[1].rm_so < MAX_BUF));
	assert((pmatch[1].rm_eo >= 0) && (pmatch[1].rm_eo < MAX_BUF));
	l = pmatch[1].rm_eo - pmatch[1].rm_so;
	if (l == 0)
	    return FALSE;
	assert((l > 0) && (l < MAX_BUF));
	strncpy(buf, str + pmatch[1].rm_so, l);
	buf[l] = '\0';
	act->target = str_create(buf);
	return TRUE;
    default:
	assert(FALSE);
    }
    /*NOTREACHED*/
    return FALSE;
}


/*
 *   this function mostly will just increment the sequence number
 * and print another prompt.  If an update command is sent it
 * first sequences through the nodes send out the'r status as a
 * '0', '1', or '?'.
 */
void cli_reply(Cluster * cluster, Action * act)
{
    Client *client = act->client;
    int seq = act->seq;
    Node *node;
    ListIterator node_i;
    int n;
    size_t nm = MAX_MATCH;
    regmatch_t pm[MAX_MATCH];
    int eflags = 0;
    regex_t nre;
    reg_syntax_t cflags = REG_EXTENDED;

    CHECK_MAGIC(act);
    CHECK_MAGIC(client);
    assert(client->fd != NO_FD);

    client->write_status = CLI_WRITING;
    if ((act->client->loggedin == FALSE) && (act->com != PM_LOG_IN)) {
	buf_printf(client->to, "LOGIN FAILED\r\n%d Password> ", seq);
    } else {
	node_i = list_iterator_create(cluster->nodes);
	switch (act->com) {
	case PM_ERROR:
	    buf_printf(client->to, "ERROR\r\n%d PowerMan> ", seq);
	    break;
	case PM_LOG_IN:
	    act->client->loggedin = TRUE;
	case PM_CHECK_LOGIN:
	    buf_printf(client->to, "%d PowerMan> ", seq);
	    break;
	case PM_LOG_OUT:
	    break;
	case PM_UPDATE_PLUGS:
	    while ((node = list_next(node_i))) {
		if (node->p_state == ST_ON)
		    buf_printf(client->to, "1");
		else if (node->p_state == ST_OFF)
		    buf_printf(client->to, "0");
		else
		    buf_printf(client->to, "?");
	    }
	    buf_printf(client->to, "\r\n%d PowerMan> ", seq);
	    break;
	case PM_UPDATE_NODES:
	    while ((node = list_next(node_i))) {
		if (node->n_state == ST_ON)
		    buf_printf(client->to, "1");
		else if (node->n_state == ST_OFF)
		    buf_printf(client->to, "0");
		else
		    buf_printf(client->to, "?");
	    }
	    buf_printf(client->to, "\r\n%d PowerMan> ", seq);
	    break;
	case PM_POWER_ON:
	case PM_POWER_OFF:
	case PM_POWER_CYCLE:
	case PM_RESET:
	    buf_printf(client->to, "%d PowerMan> ", seq);
	    break;
	case PM_NAMES:
	    Regcomp(&nre, str_get(act->target), cflags);
	    while ((node = list_next(node_i))) {
		n = Regexec(&nre, str_get(node->name), nm, pm, eflags);
		if ((n != REG_NOMATCH)
		    && ((pm[0].rm_eo - pm[0].rm_so) ==
			str_length(node->name)))
		    buf_printf(client->to, "%s\r\n",
				str_get(node->name));
	    }
	    buf_printf(client->to, "%d PowerMan> ", seq);
	    break;
	default:
	    assert(FALSE);
	}
	list_iterator_destroy(node_i);
    }
}



/*
 *   This match utility is compatible with the list API's ListFindF
 * prototype for searching a list of Client * structs.  The match
 * criterion is an identity match on their addresses.  This comes 
 * into use in the act_find() when there is a chance an Action 
 * no longer has a client associated with it.
 */
static int _match_client(Client * client, void *key)
{
    return (client == key);
}

static void _destroy_client(Client * client)
{
    CHECK_MAGIC(client);

    if (client->fd != NO_FD) {
	Close(client->fd);
	syslog(LOG_DEBUG, "client on descriptor %d signs off",
	       ((Client *) client)->fd);
    }
    if (client->to != NULL)
	buf_destroy(client->to);
    if (client->from != NULL)
	buf_destroy(client->from);
    Free(client);
}

bool cli_exists(Client *cli)
{
    Client *client;

    client = list_find_first(powerman_clients, (ListFindF) _match_client, cli);
    return (client == NULL ? FALSE : TRUE);
}

/*
 *  This is a conventional implementation of the code in Stevens.
 * The Listener already exists and on entry and on completion the
 * descriptor is waiting on new connections.
 */
void cli_listen(void)
{
    struct sockaddr_in saddr;
    int saddr_size = sizeof(struct sockaddr_in);
    int sock_opt;
    int fd_settings;
    unsigned short listen_port;

    /* 
     * "All TCP servers should specify [the SO_REUSEADDR] socket option ..."
     *                                                  - Stevens, UNP p194 
     */
    listen_fd = Socket(PF_INET, SOCK_STREAM, 0);

    sock_opt = 1;
    Setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &(sock_opt), sizeof(sock_opt));
    /* 
     *   A client could abort before a ready connection is accepted.  "The fix
     * for this problem is to:  1.  Always set a listening socket nonblocking
     * if we use select ..."                            - Stevens, UNP p424
     */
    fd_settings = Fcntl(listen_fd, F_GETFL, 0);
    Fcntl(listen_fd, F_SETFL, fd_settings | O_NONBLOCK);

    saddr.sin_family = AF_INET;
    listen_port = conf_get_listen_port();
    saddr.sin_port = htons(listen_port);
    saddr.sin_addr.s_addr = INADDR_ANY;
    Bind(listen_fd, &saddr, saddr_size);

    Listen(listen_fd, LISTEN_BACKLOG);
}


/*
 * Read activity has been detected on the listener socket.  A connection
 * request has been received.  The new client is commemorated with a
 * Client data structure, it gets buffers for sending and receiving, 
 * and is vetted through TCP wrappers.
 */
static void _create_client(void)
{
    Client *client;
    struct sockaddr_in saddr;
    int saddr_size = sizeof(struct sockaddr_in);
    int fd_settings;
    bool accepted_client = TRUE;
    char buf[MAX_BUF];
    struct hostent *hent;
    char *ip;
    char *host;
    char *fqdn;
    char *p;

    /* create client data structure */
    client = (Client *) Malloc(sizeof(Client));
    INIT_MAGIC(client);
    client->loggedin = FALSE;
    client->read_status = CLI_READING;
    client->write_status = CLI_IDLE;
    client->seq = 0;

    client->fd = Accept(listen_fd, &saddr, &saddr_size);
    if (client->fd < 0)
    /* client died after it initiated connect and before we could accept */
    {
	_destroy_client(client);
	syslog(LOG_ERR, "Client aborted connection attempt");
	return;
    }

    /* Got the new client, now look at TCP wrappers */
    /* get client->ip */
    if (inet_ntop(AF_INET, &saddr.sin_addr, buf, MAX_BUF) == NULL) {
	Close(client->fd);
	_destroy_client(client);
	syslog(LOG_ERR, "Unable to convert network address into string");
	return;
    }
    client->to = buf_create(client->fd, MAX_BUF, NULL, NULL);
    client->from = buf_create(client->fd, MAX_BUF, NULL, NULL);
    client->port = ntohs(saddr.sin_port);
    p = buf;
    while ((p - buf < MAX_BUF) && (*p != '/'))
	p++;
    if (*p == '/')
	*p = '\0';
    client->ip = str_create(buf);
    ip = str_get(client->ip);
    fqdn = ip;
    host = STRING_UNKNOWN;

    /* get client->host */
    if ((hent =
	 gethostbyaddr((const char *) &saddr.sin_addr,
		       sizeof(struct in_addr), AF_INET)) == NULL) {
	syslog(LOG_ERR, "Unable to get host name from network address");
    } else {
	client->host = str_create(hent->h_name);
	host = str_get(client->host);
	fqdn = host;
    }

    if (conf_get_use_tcp_wrappers() == TRUE) {
	accepted_client = hosts_ctl(DAEMON_NAME, host, ip, STRING_UNKNOWN);
	if (accepted_client == FALSE) {
	    Close(client->fd);
	    _destroy_client(client);
	    syslog(LOG_ERR, "Client rejected: <%s, %d>", fqdn,
		   client->port);
	    return;
	}
    }

    /*
     * We'll need to add the new fd to the list, mark it non-blocking,
     * and initiate the PM_LOG_IN sequence.
     */
    fd_settings = Fcntl(client->fd, F_GETFL, 0);
    Fcntl(client->fd, F_SETFL, fd_settings | O_NONBLOCK);

    /* append to the list of clients */
    list_append(powerman_clients, client);

    syslog(LOG_DEBUG, "New connection: <%s, %d> on descriptor %d",
	   fqdn, client->port, client->fd);
    client->write_status = CLI_WRITING;
    buf_printf(client->to, "PowerMan V1.0.0\r\npassword> ");
}


/* handle any client activity (new connection or read/write) */
void cli_process_select(fd_set *rset, fd_set *wset, bool over_time)
{
    ListIterator itr;
    Client *client;
    
    /* New connection?  Instantiate a new client object. */
    if (FD_ISSET(listen_fd, rset))
	_create_client();

    itr = list_iterator_create(powerman_clients);
    /* Client reading and writing?  */
	while ((client = list_next(itr))) {
	    if (client->fd < 0)
		continue;
	    if (FD_ISSET(client->fd, rset))
		_handle_client_read(client);
	    if (FD_ISSET(client->fd, wset))
		_handle_client_write(client);

	    /* Is this connection done? */
	    if ((client->read_status == CLI_DONE) &&
		(client->write_status == CLI_IDLE))
		list_delete(itr);
	}
    list_iterator_destroy(itr);
}

void cli_prepfor_select(fd_set *rset, fd_set *wset, int *maxfd)
{
    ListIterator itr;
    Client *client;

    if (listen_fd != NO_FD) {
	assert(listen_fd >= 0);
	FD_SET(listen_fd, rset);
	*maxfd = MAX(*maxfd, listen_fd);
    }

    itr = list_iterator_create(powerman_clients);
    while ((client = list_next(itr))) {
	if (client->fd < 0)
	    continue;

	if (client->read_status == CLI_READING) {
	    FD_SET(client->fd, rset);
	    *maxfd = MAX(*maxfd, client->fd);
	}
	if (client->write_status == CLI_WRITING) {
	    FD_SET(client->fd, wset);
	    *maxfd = MAX(*maxfd, client->fd);
	}
    }
    list_iterator_destroy(itr);
}

/*
 * vi:softtabstop=4
 */
