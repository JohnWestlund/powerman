#!/usr/bin/env python
####################################################################
# $Id$
# by Andrew C. Uselton <uselton2@llnl.gov> 
# Copyright (C) 2000 Regents of the University of California
# See ./DISCLAIMER
# v. 0-1-6:  2001-09-07
#            Initial development for Ice Box.  N.B. Unlike all the
#            other low level modules, icebox is responsible for
#            both query and control interfaces, thus the usage
#            is a combination of the prototypes for the other low
#            level modules and resembles "pm" more than the others.
#            Furthermore, the Ice Box responds to more commands than
#            just [on | off | reset].
#            Also note that we no longer support bitmap mode
#            Use -q for quiet mode rather than -v for verbose
# v. 0-1-7:  2001-09-17
#            Change the behavior of unfull iceboxes such that the
#            collective operation is not called, thus only a request
#            for ten of ten ports will invoke the collective
#            command.
#            Fixed a bug in which more than one readline() is
#            necessary before a query's response arrives.
####################################################################

import sys
import commands
import string
import getopt
import os
import fcntl, FCNTL
import time

class NodeClass:
    "Class definition for icebox attached nodes"
    name = ""
    tty  = ""
    box  = ""
    port = ""

    def __init__(self, name, tty, box, port):
        "Node class initialization"
        self.name = name
        self.tty  = tty
        self.box  = box
        self.port = port

class PortClass:
    "Class definition for an icebox port"
    name      = ""
    node      = None
    requested = 0

    def __init__(self, name, node):
        "Port class initialization"
        self.name      = name
        self.node      = node
        self.requested = 0

class BoxClass:
    "Class definition for an icebox"
    name             = ""
    tty              = ""
    ports            = {}
    sorted_port_list = []
    num_connected    = 0
    num_requested    = 0

    def __init__(self, name, tty):
        "Box class initialization"
        self.name             = name
        self.tty              = tty
        self.ports            = {}
        self.sorted_port_list = []
        self.num_connected    = 0
        self.num_requested    = 0

    def add(self, port):
        "Add a port to the list of occupied ports on the icebox"
        self.ports[port.name] = port
        self.sorted_port_list.append(port.name)
        self.num_connected    = self.num_connected + 1

class TtyClass:
    "Class definition for a tty with icebox(es) attached"
    name            = ""
    boxes           = {}
    sorted_box_list = []

    def __init__(self, name):
        "Tty class initialization"
        self.name            = name
        self.boxes           = {}
        self.sorted_box_list = []

def usage(msg):
    print "usage:", sys.argv[0], "[-a] [-c conf] [-f fan] [-l ldir] [-q] [-r] [-t] [-V] [-w node,...] [on | off | reset | temp | tempf | ice n cm]"
    print "-a       = on/off/reset all nodes"
    print "-c conf  = configuration file (default: <ldir>/etc/bogus.conf)"
    print "-f fan   = fanout for parallelism (default: 256 where implemented)"
    print "-l ldir  = powerman lirary directory (default: /usr/lib/powerman)"
    print "-q       = suppress printing any errors that may have occurred"
    print "-r       = reverse sense, i.e. check for  nodes that are off"
    print "-t       = return the temperature rather than power status"
    print "-V       = print version and exit"
    print "-w nodes = comma separated list of nodes"
    print "-w -     = read nodes from stdin, one per line"
    print "on       = turn on nodes (the default)"
    print "off      = turn off nodes"
    print "reset    = reset nodes"
    print "temp     = print the temperature status"
    print "tempf    = print the full temperature status"
    print "ice n cm = send cm to Ice Box number n"
    print msg
    sys.exit(0)

log = None
error_msg = {}
error_msg[1]  = "You must be root to run this"
error_msg[2]  = "Error attempting to id -u"
error_msg[3]  = "Unrecognized command"
error_msg[4]  = "This should be a list"
error_msg[5]  = "Couldn\'t find library directory"
error_msg[6]  = "Couldn\'t find library directory"
error_msg[7]  = "Couldn\'t find configuration file"
error_msg[8]  = "Couldn\'t find log file"
error_msg[9]  = "Unable to access icebox control device on tty"
error_msg[10] = "Unable to gain exclusive lock on icebox control device on tty"
error_msg[11] = "Error returned from tty"
error_msg[12] = "Not a recogognized node name"
error_msg[13] = "Unable to access icebox control device on tty"
error_msg[14] = "Unable to gain exclusive lock on icebox control device on tty"
error_msg[15] = "Error returned from icebox"
error_msg[16] = "Unexpected return (not a list) from box"
error_msg[17] = "Unexpected return (not a port state pair) from box"
error_msg[18] = "Unexpected return (not a list) from box"
error_msg[19] = "Unexpected return (not a port temp pair) from box"
error_msg[20] = "Error returned from port"
error_msg[21] = "Unexpected return (not a port state pair) from port"
error_msg[22] = "Unexpected return (not a port temp pair) from port"

def exit_error(msg_num, msg_data):
    if (log):
        log.write ("icebox: " + error_msg[msg_num] + ": " + msg_data + ".\n")
        log.flush()
    if(verbose):
        sys.stderr.write ("icebox: " + error_msg[msg_num] + ": " + msg_data + ".\n")
    sys.exit(1)

def init(f):
    "Read in the node, tty, box, and port for each node from the configuration file"
    node             = None
    nodes            = {}
    sorted_node_list = []
    tty              = None
    ttys             = {}
    sorted_tty_list  = []
    box              = None
    port             = None
    line = f.readline()
    while (line):
        tokens = string.split(line)
        # you need this here because of the "coninue"s below
        line = f.readline()
	if(len(tokens) < 4):
            continue
        if (tokens[0][0] == '#'): continue
        node = NodeClass(tokens[0], tokens[1], tokens[2], tokens[3])
        nodes[tokens[0]] = node
        sorted_node_list.append(node)
        port = PortClass(tokens[3], node)
        try:
            tty = ttys[tokens[1]]
        except KeyError:
            tty = TtyClass(tokens[1])
            sorted_tty_list.append(tokens[1])
            ttys[tokens[1]] = tty
        try:
            box = tty.boxes[tokens[2]]
        except KeyError:
            box = BoxClass(tokens[2], tokens[1])
            tty.boxes[tokens[2]] = box
            tty.sorted_box_list.append(tokens[2])
        box.add(port)
        box.sorted_port_list.append(tokens[3])
    return nodes, ttys, sorted_node_list, sorted_tty_list

Version = "icebox:Powerman 0.1.7"

# Check for level of permision and exit for non-root users

stat, uid = commands.getstatusoutput('/usr/bin/id -u')
if (stat == 0):
    if (uid != '0'):
        exit_error(1, "")
else:
    exit_error(2, "")

# initialize globals
powermandir  = '/usr/lib/powerman/'
config_file = 'etc/icebox.conf'
verbose     = 1
reverse     = 0
temperature = 0
names       = []
com         = 'ns'
opts        = ''
all         = 0
fanout      = 256
setting     = 0
ICEBOX_SIZE = 10
PORT_DELAY  = 0.5
BOX_DELAY   = 4.0

# Look for environment variables and set globals

try:
    test = os.environ['POWERMANDIR']
    if (os.path.isdir(test)):
        powermandir = test
except KeyError:
    pass

# Parse the command line, check for sanity, and set globals

try:
    opts, args = getopt.getopt(sys.argv[1:], 'ac:f:l:rw:tvV')
except getopt.error:
    usage("Error processing options\n")

if(not opts):
    usage("provide a list of nodes")

for opt in opts:
    op, val = opt
    if (op == '-a'):
        all = 1
    elif (op == '-c'):
        config_file = val
    elif (op == '-f'):
        fanout = val
    elif (op == '-l'):
        powermandir  = val
    elif (op == '-q'):
        verbose = 0
    elif (op == '-r'):
        reverse = 1
    elif (op == '-t'):
        com = 'ts'
    elif (op == '-V'):
        print Version
        sys.exit(0)
    elif (op == '-w'):
        if (val == '-'):
            name = sys.stdin.readline()
            while (name):
                if (name[-1:] == '\n'):
                    name = name[:-1]
                names.append(name)
                name = sys.stdin.readline()
        else:
            names = string.split(val, ',')
    else:
        usage("Unrecognized option " + op + "\n")

try:
    if (args and args[0]):
        if (args[0] == 'off'):
            com = 'pl'
            setting = 1
        elif (args[0] == 'on'):
            com = 'ph'
            setting = 1
        elif (args[0] == 'reset'):
            com = 'rp'
            setting = 1
        elif (args[0] == 'temp'):
            com = 'ts'
        elif (args[0] == 'tempf'):
            com = 'tsf'
        elif (args[0] == 'ice'):
            if (len(args) == 4):
                com = 'ice'
                targettty = args[1]
                targetcom = 'c' + args[2] + args[3]
        else:
            exit_error(3, args[0] )
except TypeError:
    exit_error(4, args)

if (powermandir):
    if (powermandir[-1] != '/'):
        powermandir = powermandir + '/'
    if(os.path.isdir(powermandir)):
        sys.path.append(powermandir)
        config_file = powermandir + config_file
    else:
        exit_error(5, powermandir)
else:
    exit_error(6, powermandir)
    
try:
    # I could put in a shared lock here, but it doesn't seem highly necessary
    f = open(config_file, 'r')
    nodes, ttys, sorted_node_list, sorted_tty_list = init(f)
    f.close()
except IOError :
    exit_error(7, config_file)
    
log_file = powermandir + "log/log_file"
try:
    # I could put in a shared lock here, but it doesn't seem highly necessary
    log = open(log_file, 'w')
except IOError :
    exit_error(8, log_file)
stat, datestring = commands.getstatusoutput('date')
log.write("\n" + datestring + "\n")
log.flush()


if (com == "ice"):
    # This only happens for directly invoking icebox on the command line
    # pm will never call it, and is never called from pm
    response = ''
    # just pass along the command
    try:
        f = open(targettty, 'r+')
    except IOError:
        exit_error(9, targettty)
    try:
        fcntl.lockf(f.fileno(), FCNTL.LOCK_EX | FCNTL.LOCK_NB)
    except IOError:
        exit_error(10, targettty)
    log.write("say:  " + targetcom)
    log.flush()
    f.write(targetcom)
    response = f.readline()
    log.write("hear:  " + response)
    log.flush()
    if (string.lower(response) != 'ok'):
        exit_error(11, targettty)
    f.close()
    exit(0)
    
if (all):
    for name in sorted_node_list:
        box = ttys[nodes[name].tty].boxes[nodes[name].box]
        box.ports[nodes[name].port].requested = 1
        box.num_requested = box.num_requested + 1
else:
    for name in names:
        try:
            box = ttys[nodes[name].tty].boxes[nodes[name].box]
            box.ports[nodes[name].port].requested = 1
            box.num_requested = box.num_requested + 1
        except KeyError:
            exit_error(12, name)
            
        
# carry out the requested command on each node
for tty_name in sorted_tty_list:
    tty = ttys[tty_name]
    try:
        f = open(tty_name, 'r+')
    except IOError:
        exit_error(13, tty_name)
    try:
        fcntl.lockf(f.fileno(), FCNTL.LOCK_EX | FCNTL.LOCK_NB)
    except IOError:
        exit_error(14, tty_name)
    for box_name in tty.sorted_box_list:
        box = tty.boxes[box_name]
        if (box.num_requested == ICEBOX_SIZE):
            target = 'c' + box.name + com + '\r\n'
            response = ''
            log.write("say:  " + target)
            log.flush()
            f.write(target)
            time.sleep(BOX_DELAY)
            response = f.readline()
            log.write("hear:  " + response)
            log.flush()
            while ((response[-1:] == '\n') or (response[-1:] == '\r')):
                response = response[:-1]
            if ((com == 'on') or (com == 'off') or (com == 'reset')):
                if (string.lower(response) != 'ok'):
                    exit_error(15, box.name)
            elif(com == 'ns'):
                try:
                    list = string.split(response)
                except ValueError:
                    exit_error(16, box.name)
                for resp in list:
                    try:
                        p,state = string.split(resp, ':')
                    except ValueError:
                        exit_error(17, box.name)
                    if (((state == '0') and reverse) or ((state == '1') and not reverse)):
                        try:
                            nm = box.ports[p[1:2]].node.name
                        except KeyError:
                            continue
                        print nm
            elif((com == 'ts') or (com == 'tsf')):
                try:
                    list = string.split(response)
                except ValueError:
                    exit_error(18, box.name)
                for resp in list:
                    try:
                        p,temps = string.split(resp, ':')
                    except ValueError:
                        exit_error(19, box.name)
                        try:
                            nm = box.ports[p[1:2]].node.name
                        except KeyError:
                            continue
                        print nm + ":" + temps
        else:
            # (num_requested != ICEBOX_SIZE):
            for port_name in box.sorted_port_list:
                port = box.ports[port_name]
                if (port.requested == 0):
                    continue
                target = 'c' + box.name + com + port.name + '\r\n'
                response = ''
                log.write("say:  " + target)
                log.flush()
                f.write(target)
                time.sleep(PORT_DELAY)
                retry_count = 0
                while ((response == '') and (retry_count < 10)):
                    response = f.readline()
                    log.write("hear:  " + response)
                    log.flush()
                    while ((response[-1:] == '\n') or (response[-1:] == '\r')):
                        response = response[:-1]
                    retry_count = retry_count + 1
                if ((com == 'on') or (com == 'off') or (com == 'reset')):
                    if (string.lower(response) != 'ok'):
                        exit_error(20, port.name)
                elif(com == 'ns'):
                    try:
                        p,state = string.split(response, ':')
                    except ValueError:
                        exit_error(21, port.name)
                    if (((state == '0') and reverse) or ((state == '1') and not reverse)):
                        print port.node.name
                elif((com == 'ts') or (com == 'tsf')):
                    try:
                        p,temps = string.split(response, ':')
                    except ValueError:
                        exit_error(22, port.name)
                    print port.node.name + ":" + temps
                    
    fcntl.lockf(f.fileno(), FCNTL.LOCK_UN)
    f.close()
sys.exit(0)
