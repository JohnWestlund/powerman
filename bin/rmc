#!/usr/bin/expect --
####################################################################
# $Id$
# by Andrew C. Uselton <uselton2@llnl.gov> 
# Copyright (C) 2000 Regents of the University of California
# See ../DISCLAIMER
# v. 0-1-0:  2001-08-20
#            This just wraps Chris's expect scripts to make an 
#            executable for power on/off/reset
# v. 0-1-1:  2001-08-31
#            renovation in support of rpm builds
# v. 0-1-2:  2001-09-05
# v. 0-1-3:  2001-09-05
####################################################################
# rmc -w node,... [on | off | reset]

set Version "rmc:powerman 0.1.3"

source /usr/lib/conman/conman.exp

proc usage msg {
  global argv0
  puts "usage: $argv0 \[-a\] \[-c conf\] \[-f fan\] \[-l ldir\] \[-w node,...\] \[-v\] \[-V\] \[on | off | reset\]"
  puts "-a       = on/off/reset all nodes"
  puts "-c conf  = configuration file (default: <ldir>/etc/bogus.conf)"
  puts "-f fan   = fanout for parallelism (default: 256 where implemented)"
  puts "-l ldir  = powerman lirary directory (default: /usr/lib/powerman)"
  puts "-w nodes = comma separated list of nodes"
  puts "-w -     = read nodes from stdin, one per line"
  puts "on       = turn on nodes (the default)"
  puts "off      = turn off nodes"
  puts "reset    = reset nodes"
  puts $msg
  exit
}


###Chris's code below
##
# Alpha Library Functions
#   or Alien Life Form (ALF)
##
# $Id$
#   by Chris Dunlap <cdunlap@llnl.gov>
##
####################################################################
# Copyright (C) 2000 Regents of the University of California
# See ../DISCLAIMER
####################################################################


proc alpha_do_rmc_cmd {spawn_id output_id console echo cmd} {
#
# Executes the RMC 'cmd' on the console session associated with 'spawn_id'.
#   If 'echo' is non-zero, output will be sent to the user via 'output_id'.
# Returns 1 if the RMC cmd is successful; o/w, returns 0.
#
# Commands tested: power on, power off, halt in, halt out, reset, status.
#
# NOTE: Does not work on ds20.
#
  set send_slow {1 0.25}
  exp_send -s "\033\033rmc"
  set timeout 2
  expect -gl "^RMC>\$" {
    ;# exp_break
  } -gl "\r\n" {
    exp_continue -continue_timer
  } eof {
    return 0
  } timeout {
    if {$timeout == 2} {		;# already at RMC?
      exp_send "\r"
      set timeout 1
      exp_continue
    } else {				;# no RMC? i'm outta here!
      return 0
    }
  }

  set status 1
  set timeout 10
  exp_send -- "$cmd\r"
  expect -gl "^$cmd\r\n" {
    exp_continue -continue_timer	;# expect the cmd just sent
  } -nocase -re "(^\[^\r]*(unknown command|power is off)\[^\r]*)\r\n" {
    if {$echo} {exp_send -i $output_id "$expect_out(1,string)\n"}
    set status 0
    exp_continue -continue_timer
  } -gl "^RMC>\$" {
    set echo 0
    exp_send "quit\r"
    exp_continue -continue_timer
  } -gl "^Returning to COM port\r\n" {
    ;# exp_break
  } -re "(^\[^\r]*)\r\n" {
    if {$echo} {exp_send -i $output_id "$expect_out(1,string)\n"}
    exp_continue -continue_timer
  } eof {
    return 0
  } timeout {
    return 0
  }
  return $status
}


proc alpha_is_at_srm {spawn_id output_id console {tmout 3}} {
#
# Checks whether the console session associated with 'spawn_id' is at SRM.
#   Times-out after approx 'tmout' secs; if you are waiting for the SRM prompt
#   following a reset, you will want to specify a longer timeout (eg, 120 secs).
# Returns 1 if the console is at SRM; o/w, returns 0.
#
  set again 1				;# sometimes the first \r gets lost
  set timeout 1				;#   so try again in a second
  exp_send "\r"
  expect -re "\nCPU \[0-9]+ booting" {
    exp_send "\003"
    exp_continue -continue_timer
  } -gl ">>>\$" {
    return 1
  } -gl "\r" {
    exp_continue -continue_timer
  } eof {
    return 0
  } timeout {
    if {$again > 0} {
      incr again -1
      set timeout $tmout
      exp_send "\r"
      exp_continue
    } else {
      return 0
    }
  }
}


proc alpha_do_srm_cmd {spawn_id output_id console echo cmd} {
#
# Executes the SRM 'cmd' on the console session associated with 'spawn_id'.
#   If 'echo' is non-zero, output will be sent to the user via 'output_id'.
# Returns 1 if the SRM cmd is successful; o/w, returns 0.
#
  if {! [alpha_is_at_srm $spawn_id $output_id $console]} {
    return 0
  }
  set status 1
  set timeout 10
  exp_send -- "$cmd\r"
  expect -gl "^$cmd\r\n" {
    exp_continue -continue_timer	;# expect the cmd just sent
  } -nocase -gl "(^\[^\r]*jumping to bootstrap code\[^\r]*)\r\n" {
    if {$echo} {exp_send -i $output_id "$expect_out(1,string)\n"}
    return 1				;# success for "boot" cmd
  } -nocase -re "(^\[^\r]*(bad value|invalid|no such command)\[^\r]*)\r\n" {
    if {$echo} {exp_send -i $output_id "$expect_out(1,string)\n"}
    set status 0
    exp_continue -continue_timer
  } -re "^\[^\r]*>>>\$" {
    ;# exp_break
  } -re "(^\[^\r]*)\r\n" {
    if {$echo} {exp_send -i $output_id "$expect_out(1,string)\n"}
    exp_continue -continue_timer
  } eof {
    return 0
  } timeout {
    return 0
  }
  return $status
}


proc alpha_get_mac_addrs {spawn_id output_id console {errmsg_r {}}} {
#
# Queries SRM on the console associated with 'spawn_id' via "show dev".
# Returns a list of MAC addresses.
# On error, a message is written to the 'errmsg_r' var reference if present.
#
  upvar $errmsg_r errmsg
  set errmsg "Undefined"
  set macs {}

  if {! [alpha_is_at_srm $spawn_id $output_id $console]} {
    set errmsg "Not at SRM prompt"
    return
  }
  set word "\[^ \t\r\n]+"
  set x "\[0-9A-Fa-f]"
  set addr "$x$x-$x$x-$x$x-$x$x-$x$x-$x$x"

  exp_send "show dev\r"
  set timeout 10
  expect -gl "No such command" {
    set errmsg "No such command"
    return
  } -re "\n($word) +($word) +($addr) *\r" {
    lappend macs \
      [list $expect_out(1,string) $expect_out(2,string) $expect_out(3,string)]
    exp_continue -continue_timer
  } -gl ">>>\$" {
    ;# exp_break
  } -gl "\r" {
    exp_continue -continue_timer
  } eof {
    set errmsg "Exited"
    return
  } timeout {
    set errmsg "Timed-out"
    return
  }
  return $macs
}

#back to Andrew's wrapper

set config_file "etc/rmc.conf"
set lib_dir     "/usr/lib/powerman"
set names []
set command {power on}
set all 0
set fanout  256

if {$argc == 0} {
    usage "provide a list of nodes"
}

for {set i 0} {$i < $argc} {incr i} {
  switch -- [lindex $argv $i] {
      "-a"    { set all 1 }
      "-c"    { 
	  incr i
	  set config_file [lindex $argv $i]
      }
      "-f"    { 
	  incr i
	  set fanout [lindex $argv $i]
      }
      "-l"    { 
	  incr i
	  set lib_dir [lindex $argv $i]
      }
      "-w"    { 
	  incr i
	  set name_list [lindex $argv $i]
	  if {$name_list == "-"} {
	      while {! [eof stdin]} {
		  gets stdin name
		  lappend names $name
	      }
	  } else {
	      set names [split $name_list ,]
	  }
      }
      "-v"    { set verbose 1 }
      "-V"    { 
	  puts $Version
	  exit
      }
      "on"     {set command {power on}}
      "off"    {set command {power off}}
      "reset"  {set command reset}
      default {usage [format "unrecognized option %s" [lindex $argv $i]]}
  }
}

# as yet unimplemented is to have an rmc.conf file listing the rmc
# based nodes.  Then a -a command knows how to build its names list.

log_user 0

set nodes_and_options [linsert $names 0 "-j"]
conman_run $fanout $nodes_and_options alpha_do_rmc_cmd 0 $command
